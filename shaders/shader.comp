#version 450

// Needed so that final output spans the entire texture
layout (local_size_x = 16, local_size_y = 16) in;
// The output of the raytracing pass is going to be written here
layout (binding = 0, rgba8) uniform writeonly image2D resultImage;

// Defining some constants
// This will only work in GLSL 4.4 and above!
const mediump float INFINITY = 1.0 / 0.0;

// UBO for storing camera values
layout(binding = 1) uniform Camera {
    vec3 origin;
    vec3 lower_left_corner;
    vec3 horizontal;
    vec3 vertical;
} cam;

struct Triangle {
    mediump vec3 v0;
    mediump vec3 v1;
    mediump vec3 v2;
    mediump vec3 normal;
};

layout (std140, binding = 2) buffer Triangles {
	Triangle triangles[];
};

// Function for generating random numbers
// https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl
float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898, 78.233))) * 43758.5453);
}

// A struct used for recording data about intersections
struct HitRecord {
    mediump float t;
    mediump vec3 p;
    mediump vec3 normal;
};

// Setup for ray creation
struct Ray {
    mediump vec3 A;
    mediump vec3 B;
} ray;

vec3 ray_origin(in Ray r) {
    return r.A;
}

vec3 ray_direction(in Ray r) {
    return r.B;
}

vec3 ray_point_at_param(in Ray r, in float t) {
    return r.A + t * r.B;
}

vec3 unit_vector(in vec3 v) {
    return v / length(v);
}

// Sphere stuff
struct Sphere {
    mediump vec3 center;
    mediump float radius;
};

bool sphere_hit(in Ray r, in Sphere sphere, in float t_min, in float t_max,
    inout HitRecord rec) {
    mediump vec3 oc = vec3(ray_origin(r) - sphere.center);
    mediump vec3 direction = ray_direction(r);
    mediump float a = dot(direction, direction);
    mediump float b = dot(oc, direction);
    mediump float c = dot(oc, oc) - sphere.radius * sphere.radius;
    mediump float discriminant = b * b - a * c;

    if (discriminant > 0.0) {
        mediump float sqrt_disc = sqrt(discriminant);
        mediump float temp = (-b - sqrt_disc) / a;
        if (temp < t_max && temp > t_min) {
            rec.t = temp;
            rec.p = ray_point_at_param(r, rec.t);
            rec.normal = (rec.p - sphere.center) / sphere.radius;
            return true;
        }

        temp = (-b + sqrt_disc) / a;
        if (temp < t_max && temp > t_min) {
            rec.t = temp;
            rec.p = ray_point_at_param(r, rec.t);
            rec.normal = (rec.p - sphere.center) / sphere.radius;
            return true;
        }
    }
    return false;
}

bool hit(in Ray r, in Sphere[2] spheres, in float t_min, in float t_max,
    inout HitRecord rec) {
    HitRecord temp_rec;
    bool hit_anything = false;
    mediump float closest_so_far = t_max;
    for (int i = 0; i < spheres.length(); i++) {
        if (sphere_hit(r, spheres[i], t_min, closest_so_far, temp_rec)) {
            hit_anything = true;
            closest_so_far = temp_rec.t;
            rec = temp_rec;
        }
    }
    return hit_anything;
}

vec3 render(in Ray r, in Sphere[2] spheres) {
    HitRecord rec;
    // Iterate over all spheres for now
    if (hit(r, spheres, 0.0, INFINITY, rec)) {
        return 0.5 * vec3(rec.normal + 1);
    }
    else {
        mediump vec3 unit_direction = unit_vector(ray_direction(r));
        mediump float t = 0.5 * (unit_direction.y + 1.0);
        return (1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0);
    }
}

void main() {
    ivec2 dim = imageSize(resultImage);
    vec2 uv = vec2(gl_GlobalInvocationID.xy) / dim;

    // Add some spheres
    Sphere spheres[2] = Sphere[2](Sphere(vec3(0, 0, -1), 0.5),
                                  Sphere(vec3(0, -100.5, -1), 100));

    Ray r = Ray(cam.origin,
                cam.lower_left_corner + uv.x * cam.horizontal + uv.y * cam.vertical);

    lowp vec3 finalColor = render(r, spheres);
    imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(finalColor, 0.0));
}