#version 450

// Needed so that final output spans the entire texture
layout(local_size_x = 16, local_size_y = 16) in;
// The output of the raytracing pass is going to be written here
layout(binding = 0, rgba8) uniform writeonly image2D resultImage;

// Defining some constants
// This will only work in GLSL 4.4 and above!
#define M_PI 3.1415926535897932384626433832795

const float INFINITY = 1.0 / 0.0;
const float EPSILON = 0.001;
const int NUM_BOUNCES = 3;
const int NUM_SAMPLES = 32;

// UBO for storing camera values
layout(binding = 1) uniform Camera {
  vec3 origin;
  vec3 lower_left_corner;
  vec3 horizontal;
  vec3 vertical;
  vec3 u;
  vec3 v;
  vec3 w;
  float lens_radius;
}
cam;

struct Triangle {
  vec3 v0;
  vec3 v1;
  vec3 v2;
  vec3 normal;
};

layout(std140, binding = 2) buffer Triangles { Triangle triangles[]; };

// Function for generating random numbers
// https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl
float rand(vec2 co) {
  return 2.0 * fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453) - 1;
}

// Struct to describe material interaction. The material type
// is IDed through a simple integer. The mapping is as follows:
// * 1 - Diffuse
// * 2 - Metal
// * 3 - Glass
const int LAMBERTIAN = 1;
const int METAL = 2;
const int DIELECTRIC = 3;
struct Material {
  vec3 albedo;
  float fuzz;
  float ref_idx;
  int scatter_function;
};

// A struct used for recording data about intersections
struct HitRecord {
  float t;
  vec3 p;
  vec3 normal;
  Material mat;
};

// Setup for ray creation
struct Ray {
  vec3 origin;
  vec3 direction;
};

vec3 ray_point_at_param(in Ray ray, in float t) {
  return ray.origin + t * ray.direction;
}

vec3 random_in_unit_disk(in vec2 co) {
  vec3 p;
  int n = 0;
  do {
    p = vec3(rand(co.xy), rand(co.yx), 0.0) - vec3(1.0, 1.0, 0.0);
    n++;
  } while (dot(p, p) >= 1.0 && n < 3);
  return p;
}

Ray get_ray(in float u, in float v) {
  return Ray(cam.origin, cam.lower_left_corner + u * cam.horizontal +
                             v * cam.vertical - cam.origin);
}

// Sphere stuff
struct Sphere {
  vec3 center;
  float radius;
  Material mat;
};

// Sample the unit sphere for shadows
vec3 random_in_unit_sphere(vec3 p) {
  int n = 0;
  do {
    p = vec3(rand(p.xy), rand(p.zy), rand(p.xz));
    n++;
  } while ((length(p) * length(p)) >= 1.0 && n < 3);
  return p;
}

bool sphere_hit(in Ray ray, in Sphere sphere, in float t_min, in float t_max,
                inout HitRecord rec) {
  vec3 oc = vec3(ray.origin - sphere.center);
  float a = dot(ray.direction, ray.direction);
  float b = dot(oc, ray.direction);
  float c = dot(oc, oc) - sphere.radius * sphere.radius;
  float discriminant = b * b - a * c;

  if (discriminant > 0.0) {
    float sqrt_disc = sqrt(discriminant);
    float temp = (-b - sqrt_disc) / a;
    if (temp < t_max && temp > t_min) {
      rec.t = temp;
      rec.p = ray_point_at_param(ray, rec.t);
      rec.normal = (rec.p - sphere.center) / sphere.radius;
      rec.mat = sphere.mat;
      return true;
    }

    temp = (-b + sqrt_disc) / a;
    if (temp < t_max && temp > t_min) {
      rec.t = temp;
      rec.p = ray_point_at_param(ray, rec.t);
      rec.normal = (rec.p - sphere.center) / sphere.radius;
      rec.mat = sphere.mat;
      return true;
    }
  }
  return false;
}

bool scatter_lambertian(in Ray ray, in HitRecord rec, inout vec3 attenuation,
                        inout Ray scattered) {
  vec3 target = rec.p + rec.normal + random_in_unit_sphere(rec.p);
  scattered = Ray(rec.p, target - rec.p);
  attenuation = rec.mat.albedo;
  return true;
}

bool scatter_metal(in Ray r_in, in HitRecord rec, inout vec3 attentuation,
                   inout Ray scattered) {
  vec3 reflected = reflect(normalize(r_in.direction), rec.normal);
  scattered =
      Ray(rec.p, reflected + rec.mat.fuzz * random_in_unit_sphere(rec.p));
  attentuation = rec.mat.albedo;
  return dot(scattered.direction, rec.normal) > 0.0;
}

bool refract(in vec3 v, in vec3 n, in float ni_over_nt, inout vec3 refracted) {
  vec3 uv = normalize(v);
  float dt = dot(uv, n);
  float discriminant = 1.0 - ni_over_nt * ni_over_nt * (1 - dt * dt);
  if (discriminant > 0.0) {
    refracted = ni_over_nt * (uv - n * dt) - n * sqrt(discriminant);
    return true;
  }
  return false;
}

// Schlick approximation function
float schlick(in float cosine, in float ref_idx) {
  float r0 = (1.0 - ref_idx) / (1.0 + ref_idx);
  r0 = r0 * r0;
  return r0 + (1.0 - r0) * pow((1.0 - cosine), 5);
}

bool scatter_dielectric(in Ray r_in, inout HitRecord rec,
                        inout vec3 attentuation, inout Ray scattered) {
  vec3 outward_normal;
  vec3 reflected = reflect(r_in.direction, rec.normal);
  float ni_over_nt;
  attentuation = vec3(1.0, 1.0, 1.0);
  vec3 refracted;
  float reflect_prob;
  float cosine;
  if (dot(r_in.direction, rec.normal) > 0.0) {
    outward_normal = -rec.normal;
    ni_over_nt = rec.mat.ref_idx;
    cosine = rec.mat.ref_idx * dot(r_in.direction, rec.normal) /
             length(r_in.direction);
  } else {
    outward_normal = rec.normal;
    ni_over_nt = 1.0 / rec.mat.ref_idx;
    cosine = -dot(r_in.direction, rec.normal) / length(r_in.direction);
  }

  if (refract(r_in.direction, outward_normal, ni_over_nt, refracted)) {
    reflect_prob = schlick(cosine, rec.mat.ref_idx);
  } else {
    scattered = Ray(rec.p, reflected);
    reflect_prob = 1.0;
  }

  if (rand(r_in.direction.xy) < reflect_prob) {
    scattered = Ray(rec.p, reflected);
  } else {
    scattered = Ray(rec.p, refracted);
  }

  return true;
}

bool scatter(in Ray ray, inout HitRecord rec, inout vec3 attentuation,
             inout Ray scattered) {
  if (rec.mat.scatter_function == LAMBERTIAN) {
    return scatter_lambertian(ray, rec, attentuation, scattered);
  } else if (rec.mat.scatter_function == METAL) {
    return scatter_metal(ray, rec, attentuation, scattered);
  } else {
    return scatter_dielectric(ray, rec, attentuation, scattered);
  }
}

bool intersect(in Ray ray, in Sphere[5] spheres, in float t_min, in float t_max,
               inout HitRecord rec) {
  HitRecord temp_rec;
  bool hit_anything = false;
  float closest_so_far = t_max;
  for (int i = 0; i < spheres.length(); i++) {
    if (sphere_hit(ray, spheres[i], t_min, closest_so_far, temp_rec)) {
      hit_anything = true;
      closest_so_far = temp_rec.t;
      rec = temp_rec;
    }
  }
  return hit_anything;
}

vec3 render(in Ray ray, in Sphere[5] spheres) {
  HitRecord rec;
  vec3 total_attenuation = vec3(1.0, 1.0, 1.0);
  // Iterate for a max number of bounces
  for (int i = 0; i < NUM_BOUNCES; i++) {
    if (intersect(ray, spheres, EPSILON, INFINITY, rec)) {
      // Intersected an object and need to bounce the ray
      Ray scattered;
      vec3 attenuation;
      if (scatter(ray, rec, attenuation, scattered)) {
        total_attenuation *= attenuation;
        ray = scattered;
      } else {
        total_attenuation *= vec3(0.0, 0.0, 0.0);
      }
    } else {
      // No objects intersected. Return background color
      vec3 unit_direction = normalize(ray.direction);
      float t = 0.5 * (unit_direction.y + 1.0);
      return total_attenuation *
             ((1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0));
    }
  }
}

void main() {
  ivec2 dim = imageSize(resultImage);

  // Create materials
  Material gray_diff = Material(vec3(0.1, 0.2, 0.5), 0.0, 0.0, 1);
  Material gold_diff = Material(vec3(0.8, 0.8, 0.0), 0.0, 0.0, 1);
  Material metal = Material(vec3(0.8, 0.6, 0.2), 0.0, 0.0, 2);
  Material dielectric = Material(vec3(0.0, 0.0, 0.0), 0.0, 1.5, 3);

  // Add some spheres
  Sphere spheres[5] =
      Sphere[5](Sphere(vec3(0.0, 0.0, -1.0), 0.5, gray_diff),
                Sphere(vec3(0.0, -100.5, -1.0), 100.0, gold_diff),
                Sphere(vec3(1.0, 0.0, -1.0), 0.5, metal),
                Sphere(vec3(-1.0, 0.0, -1.0), 0.5, dielectric),
                Sphere(vec3(-1.0, 0.0, -1.0), -0.45, dielectric));

  vec3 finalColor = vec3(0.0, 0.0, 0.0);
  // For loop to sample multiple times
  for (int s = 0; s < NUM_SAMPLES; s++) {
    float u =
        (gl_GlobalInvocationID.x + rand(gl_GlobalInvocationID.xy + s)) / dim.x;
    float v =
        (gl_GlobalInvocationID.y + rand(gl_GlobalInvocationID.xy + s)) / dim.y;
    Ray r0 = get_ray(u, v);
    finalColor += render(r0, spheres);
  }

  // Normalize the color with the number of samples
  finalColor /= NUM_SAMPLES;
  // Simple gamma-correction at 1/2
  finalColor = sqrt(finalColor.xyz);

  imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy),
             vec4(finalColor, 0.0));
}