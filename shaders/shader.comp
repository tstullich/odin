#version 450

// Needed so that final output spans the entire texture
layout(local_size_x = 16, local_size_y = 16) in;
// The output of the raytracing pass is going to be written here
layout(binding = 0, rgba8) uniform writeonly image2D resultImage;

// Defining some constants
// This will only work in GLSL 4.4 and above!
const float INFINITY = 1.0 / 0.0;
const float EPSILON = 0.001;
const int NUM_BOUNCES = 4;
const int NUM_SAMPLES = 32;

// UBO for storing camera values
layout(binding = 1) uniform Camera {
  vec3 origin;
  vec3 lower_left_corner;
  vec3 horizontal;
  vec3 vertical;
}
cam;

struct Triangle {
  vec3 v0;
  vec3 v1;
  vec3 v2;
  vec3 normal;
};

layout(std140, binding = 2) buffer Triangles { Triangle triangles[]; };

// Function for generating random numbers
// https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl
float rand(vec2 co) {
  return 2.0 * fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453) - 1;
}

// Struct to describe material interaction. The material type
// is IDed through a simple integer. The mapping is as follows:
// * 1 - Diffuse
// * 2 - Metal
// * 3 - Glass
const int LAMBERTIAN = 1;
const int METAL = 2;
const int DIELECTRIC = 3;
struct Material {
  vec3 albedo;
  float fuzz;
  int scatter_function;
};

// A struct used for recording data about intersections
struct HitRecord {
  float t;
  vec3 p;
  vec3 normal;
  Material mat;
};

// Setup for ray creation
struct Ray {
  vec3 A;
  vec3 B;
};

vec3 ray_origin(in Ray ray) { return ray.A; }

vec3 ray_direction(in Ray ray) { return ray.B; }

vec3 ray_point_at_param(in Ray ray, in float t) { return ray.A + t * ray.B; }

vec3 unit_vector(in vec3 v) { return v / length(v); }

Ray get_ray(in float u, in float v) {
  return Ray(cam.origin, cam.lower_left_corner + u * cam.horizontal +
                             v * cam.vertical - cam.origin);
}

// Sphere stuff
struct Sphere {
  vec3 center;
  float radius;
  Material mat;
};

// Sample the unit sphere for shadows
vec3 random_in_unit_sphere(vec3 p) {
  int n = 0;
  do {
    p = 2.0 * vec3(rand(p.xy), rand(p.zy), rand(p.xz)) - vec3(1.0, 1.0, 1.0);
    n++;
  } while ((length(p) * length(p)) >= 1.0 && n < 3);
  return p;
}

bool sphere_hit(in Ray ray, in Sphere sphere, in float t_min, in float t_max,
                inout HitRecord rec) {
  vec3 oc = vec3(ray_origin(ray) - sphere.center);
  vec3 dir = ray_direction(ray);
  float a = dot(dir, dir);
  float b = dot(oc, dir);
  float c = dot(oc, oc) - sphere.radius * sphere.radius;
  float discriminant = b * b - a * c;

  if (discriminant > 0.0) {
    float sqrt_disc = sqrt(discriminant);
    float temp = (-b - sqrt_disc) / a;
    if (temp < t_max && temp > t_min) {
      rec.t = temp;
      rec.p = ray_point_at_param(ray, rec.t);
      rec.normal = (rec.p - sphere.center) / sphere.radius;
      rec.mat = sphere.mat;
      return true;
    }

    temp = (-b + sqrt_disc) / a;
    if (temp < t_max && temp > t_min) {
      rec.t = temp;
      rec.p = ray_point_at_param(ray, rec.t);
      rec.normal = (rec.p - sphere.center) / sphere.radius;
      rec.mat = sphere.mat;
      return true;
    }
  }
  return false;
}

bool scatter_lambertian(in Ray ray, in HitRecord rec, inout vec3 attenuation,
                        inout Ray scattered) {
  vec3 target = rec.p + rec.normal + random_in_unit_sphere(rec.p);
  scattered = Ray(rec.p, target - rec.p);
  attenuation = rec.mat.albedo;
  return true;
}

bool scatter_metal(in Ray r_in, in HitRecord rec, inout vec3 attentuation,
                   inout Ray scattered) {
  vec3 reflected = reflect(unit_vector(ray_direction(r_in)), rec.normal);
  scattered =
      Ray(rec.p, reflected + rec.mat.fuzz * random_in_unit_sphere(rec.p));
  attentuation = rec.mat.albedo;
  return dot(ray_direction(scattered), rec.normal) > 0.0;
}

bool scatter(in Ray ray, inout HitRecord rec, inout vec3 attentuation,
             inout Ray scattered) {
  if (rec.mat.scatter_function == LAMBERTIAN) {
    return scatter_lambertian(ray, rec, attentuation, scattered);
  } else if (rec.mat.scatter_function == METAL) {
    return scatter_metal(ray, rec, attentuation, scattered);
  } else {
    // TODO Implement
    return false;
  }
}

bool intersect(in Ray ray, in Sphere[4] spheres, in float t_min, in float t_max,
               inout HitRecord rec) {
  HitRecord temp_rec;
  bool hit_anything = false;
  float closest_so_far = t_max;
  for (int i = 0; i < spheres.length(); i++) {
    if (sphere_hit(ray, spheres[i], t_min, closest_so_far, temp_rec)) {
      hit_anything = true;
      closest_so_far = temp_rec.t;
      rec = temp_rec;
    }
  }
  return hit_anything;
}

vec3 render(in Ray ray, in Sphere[4] spheres) {
  HitRecord rec;
  vec3 total_attenuation = vec3(1.0, 1.0, 1.0);
  // Iterate for a max number of bounces
  for (int i = 0; i < NUM_BOUNCES; i++) {
    if (intersect(ray, spheres, EPSILON, INFINITY, rec)) {
      // Intersected an object and need to bounce the ray
      Ray scattered;
      vec3 attenuation;
      if (scatter(ray, rec, attenuation, scattered)) {
        total_attenuation *= attenuation;
        ray = scattered;
      } else {
        total_attenuation *= vec3(0.0, 0.0, 0.0);
      }
    } else {
      // No objects intersected. Return background color
      vec3 unit_direction = unit_vector(ray_direction(ray));
      float t = 0.5 * (unit_direction.y + 1.0);
      return total_attenuation *
             ((1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0));
    }
  }
}

void main() {
  ivec2 dim = imageSize(resultImage);

  // Create materials
  Material gray_diff = Material(vec3(0.8, 0.3, 0.3), 0.0, 1);
  Material gold_diff = Material(vec3(0.8, 0.8, 0.0), 0.0, 1);
  Material metal0 = Material(vec3(0.8, 0.6, 0.2), 0.3, 2);
  Material metal1 = Material(vec3(0.8, 0.8, 0.8), 1.0, 2);

  // Add some spheres
  Sphere spheres[4] =
      Sphere[4](Sphere(vec3(0.0, 0.0, -1.0), 0.5, gray_diff),
                Sphere(vec3(0.0, -100.5, -1.0), 100.0, gold_diff),
                Sphere(vec3(1.0, 0.0, -1.0), 0.5, metal0),
                Sphere(vec3(-1.0, 0.0, -1.0), 0.5, metal1));

  vec3 finalColor = vec3(0.0, 0.0, 0.0);
  // For loop to sample multiple times
  for (int s = 0; s < NUM_SAMPLES; s++) {
    float u =
        (gl_GlobalInvocationID.x + rand(gl_GlobalInvocationID.xy + s)) / dim.x;
    float v =
        (gl_GlobalInvocationID.y + rand(gl_GlobalInvocationID.xy + s)) / dim.y;
    Ray r0 = get_ray(u, v);
    finalColor += render(r0, spheres);
  }

  // Normalize the color with the number of samples
  finalColor /= NUM_SAMPLES;
  // Simple gamma-correction at 1/2
  finalColor = sqrt(finalColor.xyz);

  imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy),
             vec4(finalColor, 0.0));
}