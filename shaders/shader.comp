#version 450

// Needed so that final output spans the entire texture
layout(local_size_x = 16, local_size_y = 16) in;
// The output of the raytracing pass is going to be written here
layout(binding = 0, rgba8) uniform writeonly image2D resultImage;

// Defining some constants
// This will only work in GLSL 4.4 and above!
const mediump float INFINITY = 1.0 / 0.0;
const mediump float EPSILON = 0.001;
const int NUM_BOUNCES = 2;
const int NUM_SAMPLES = 2;

// UBO for storing camera values
layout(binding = 1) uniform Camera {
  mediump vec3 origin;
  mediump vec3 lower_left_corner;
  mediump vec3 horizontal;
  mediump vec3 vertical;
}
cam;

struct Triangle {
  mediump vec3 v0;
  mediump vec3 v1;
  mediump vec3 v2;
  mediump vec3 normal;
};

layout(std140, binding = 2) buffer Triangles { Triangle triangles[]; };

// Function for generating random numbers
// https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl
float rand(vec2 co) {
  return 2.0 * fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453) - 1;
}

// A struct used for recording data about intersections
struct HitRecord {
  mediump float t;
  mediump vec3 p;
  mediump vec3 normal;
};

// Setup for ray creation
struct Ray {
  mediump vec3 A;
  mediump vec3 B;
};

vec3 ray_origin(in Ray ray) { return ray.A; }

vec3 ray_direction(in Ray ray) { return ray.B; }

vec3 ray_point_at_param(in Ray ray, in float t) { return ray.A + t * ray.B; }

vec3 unit_vector(in vec3 v) { return v / length(v); }

Ray get_ray(in float u, in float v) {
  return Ray(cam.origin, cam.lower_left_corner + u * cam.horizontal +
                             v * cam.vertical - cam.origin);
}

// Sphere stuff
struct Sphere {
  mediump vec3 center;
  mediump float radius;
};

// Sample the unit sphere for shadows
vec3 random_in_unit_sphere() {
  mediump vec3 p;
  int n = 0;
  do {
    p = 2.0 * vec3(rand(gl_GlobalInvocationID.xy),
                   rand(gl_GlobalInvocationID.xy),
                   rand(gl_GlobalInvocationID.xy)) -
        vec3(1.0, 1.0, 1.0);
    n++;
  } while ((length(p) * length(p)) >= 1.0 && n < 3);
  return p;
}

bool sphere_hit(in Ray ray, in Sphere sphere, in float t_min, in float t_max,
                inout HitRecord rec) {
  mediump vec3 oc = vec3(ray_origin(ray) - sphere.center);
  mediump vec3 dir = ray_direction(ray);
  mediump float a = dot(dir, dir);
  mediump float b = dot(oc, dir);
  mediump float c = dot(oc, oc) - sphere.radius * sphere.radius;
  mediump float discriminant = b * b - a * c;

  if (discriminant > 0.0) {
    mediump float sqrt_disc = sqrt(discriminant);
    mediump float temp = (-b - sqrt_disc) / a;
    if (temp < t_max && temp > t_min) {
      rec.t = temp;
      rec.p = ray_point_at_param(ray, rec.t);
      rec.normal = (rec.p - sphere.center) / sphere.radius;
      return true;
    }

    temp = (-b + sqrt_disc) / a;
    if (temp < t_max && temp > t_min) {
      rec.t = temp;
      rec.p = ray_point_at_param(ray, rec.t);
      rec.normal = (rec.p - sphere.center) / sphere.radius;
      return true;
    }
  }
  return false;
}

bool intersect(in Ray ray, in Sphere[2] spheres, in float t_min, in float t_max,
               inout HitRecord rec) {
  HitRecord temp_rec;
  bool hit_anything = false;
  mediump float closest_so_far = t_max;
  for (int i = 0; i < spheres.length(); i++) {
    if (sphere_hit(ray, spheres[i], t_min, closest_so_far, temp_rec)) {
      hit_anything = true;
      closest_so_far = temp_rec.t;
      rec = temp_rec;
    }
  }
  return hit_anything;
}

vec3 render(in Ray ray, in Sphere[2] spheres) {
  HitRecord rec;
  // Iterate for a max number of bounces
  int i = NUM_BOUNCES;
  while (i > 0) {
    if (intersect(ray, spheres, EPSILON, INFINITY, rec)) {
      // Intersected an object and need to bounce the ray
      mediump vec3 target = rec.p + rec.normal + random_in_unit_sphere();
      ray = Ray(rec.p, target - rec.p);
    } else {
      // No objects intersected. Return background color
      mediump vec3 unit_direction = unit_vector(ray_direction(ray));
      mediump float t = 0.5 * (unit_direction.y + 1.0);
      return (1.0 - t) * vec3(1.0, 1.0, 1.0) + t * vec3(0.5, 0.7, 1.0);
    }
    i--;
  }
}

void main() {
  mediump ivec2 dim = imageSize(resultImage);

  // Add some spheres
  Sphere spheres[2] = Sphere[2](Sphere(vec3(0.0, 0.0, -1.0), 0.5),
                                Sphere(vec3(0.0, -100.5, -1.0), 100.0));

  lowp vec3 finalColor = vec3(0.0, 0.0, 0.0);
  // For loop to sample the pixel multiple times
  for (int i = 0; i < NUM_SAMPLES; i++) {
    mediump float u =
        (gl_GlobalInvocationID.x + rand(gl_GlobalInvocationID.xy)) / dim.x;
    mediump float v =
        (gl_GlobalInvocationID.y + rand(gl_GlobalInvocationID.xy)) / dim.y;
    Ray r0 = get_ray(u, v);
    finalColor += render(r0, spheres);
  }

  // Normalize the color with the number of samples
  finalColor /= NUM_SAMPLES;
  // Simple gamma-correction at 1/2
  sqrt(finalColor.xyz);

  imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy),
             vec4(finalColor, 0.0));
}